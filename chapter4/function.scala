//对于函数文本，标准语法(有点像匿名函数，但是不能带有返回值)可以用_当作占位符
//scala会由此推断函数需要传递的参数，比如

val add = (x: Int, y: Int) => x + y

val add = (_: Int) + (_: Int)

//这就是函数值对象，有点像取别名，也有点像匿名函数，但是提供的作用就大的很，比如出借模式

/* 偏应用函数
1、偏应用函数是一种表达式，你不需要提供函数需要的所有参数。代之以仅提供部分，或不提供所需参数。
2、偏应用函数可以包装普通函数为函数值对象
3、尽管不能把方法或嵌套函数赋值给变量，或当作参数传递给其它方法，但是如果你把方法或嵌套函数通过在名称后面加一个下划线的方式包装在函数值中，就可以做到了。
4、Scala 允许你仅在需要函数类型的地方才能省略这个仅用的 _
*/

/* 闭包
1、名称源自于通过“捕获”自由变量的绑定对函数文本执行的“关闭”行动。
2、 Scala的闭包捕获了变量本身， 而不是变量指向的值。（这个很重要）
3、由此可见闭包其实又提供了一种函数返回值的附加形式，这种方式还是尽量少用，避免代码可读性变差。
*/


/* 重复参数
1、用*就可以重复参数
2、函数内部， 重复参数的类型是声明参数类型的数组。
3、当有一个合适类型的数组，你必须: _*，告诉scala你想把每一个值当作参数传递
*/
def echo(args: String*) {
	for(arg <- args) println(arg)
}

//想要把更新 var 的 while 循环转换成仅使用 val 的更函数式风格的话，有时候你可以使用递归。
//如果方案是尾递归，就无须付出任何运行期开销。
def approximate(guess: Double):Double = {
	if(isGoodEnough(guess)) guess //如果足够好了，就返回
	else approximate(improve(guess)) //否则就改善
}

def approximateLoop(initialGuess: Double): Double = {
	var guess = initialGuess
	while (!isGoodEnough(guess))
		guess = improve(guess)
	guess
}

//尾调用优化受限于方法或嵌套函数在最后一个操作调用本身， 而没有转到某个函数值或什么其它的中间函数的情况

/* 总结：
Scala 还提供本地函数，函数文本，及函数值。 
除了普通的函数调用之外， Scala 还提供了偏应用函数和带有重复参数的函数。 
如果可能，函数调用应被实现为优化的尾调用，这样许多漂亮的递归函数就能执行的如手动优化版本的 while 循环一样快。
*/